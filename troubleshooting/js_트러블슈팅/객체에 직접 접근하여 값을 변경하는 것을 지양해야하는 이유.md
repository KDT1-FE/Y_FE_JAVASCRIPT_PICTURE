[코드 리뷰 과정에서 받은 질문](https://github.com/KDT1-FE/Y_FE_JAVASCRIPT_PICTURE/pull/54#discussion_r1306357035)

1.  Trouble

    > 아래 코드처럼 객체의 값에 직접 접근하는 것보다, setAttribute 와 같은 setter를 활용하는 게 더 안전하다는 피드백을 받았고, 왜 그러한지 공부해 보았습니다.

    ```js
    const fileReader = new FileReader();

    fileReader.onload = ({ target }) => {
      driverImgShowPreview.src = target.result;

      // ...
    };
    ```

2.  Why?

    > 객체에 직접 접근해서 값을 수정하는 것을 지양해야하는 이유는? 데이터를 불변성을 지키기 위함입니다.

    - setter 함수를 활용하면, 데이터를 불러올 때 한번 더 가공(얕은 복사 등)하는 과정을 거치므로 내부 데이터의 불변성을 지킬 수 있습니다.

    > 그럼 불변성을 지켜야하는 이유는?

    - 첫 째, 불변성이 지켜지지 않은 상태에서 원본 데이터를 변경 하면, 원본 데이터를 참조하고 있는 다른 객체에서 예상치 못한 오류를 일으킬 수 있기 때문입니다.

      ```jsx
      export const foo = {
        minsoo: {
          name: "minsoo",
          age: 29
        }
      };

      // A.js
      import { foo } from "somewhre";
      foo.minsoo = 1;

      // B.js
      import { foo } from "somewhre";

      const minsoo_name = foo.minsoo.name; // error
      ```

    - 둘 째, 리액트에서 화면을 업데이트 할 때 Diffing과정에서 실제 DOM의 불변성을 유지해야 가상 DOM과 서로 다른 부분을 정확히 구별하고 Reconciliation 할 수 있기 때문입니다.

    > 불변성을 지킬 수 있는 주요 메서드는? (새로운 배열을 반환하는 메서드)

    - spread operator(…), map, filter, slice, reduce

    > 원본을 변경 시키는 주요 메서드는?

    - splice, push

    ```

    ```

3.  Solved

    ```js
    const fileReader = new FileReader();

    fileReader.onload = ({ target }) => {
      driverImgShowPreview.setAttribute("src", `${target.result}`);

      // ...
    };
    ```
